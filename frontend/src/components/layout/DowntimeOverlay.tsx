import { useState, useEffect, useMemo } from 'react';
import { downtimeEventApi } from '../../api/endpoints.ts';
import type { DowntimeReason } from '../../types/domain.ts';
import styles from './DowntimeOverlay.module.css';

interface DowntimeOverlayProps {
  lastActivityTimestamp: number;
  reasons: DowntimeReason[];
  workCenterProductionLineId: string;
  operatorUserId: string;
  onDismiss: () => void;
}

function formatElapsed(seconds: number): string {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = seconds % 60;
  if (h > 0) return `${h}h ${String(m).padStart(2, '0')}m ${String(s).padStart(2, '0')}s`;
  return `${m}m ${String(s).padStart(2, '0')}s`;
}

export function DowntimeOverlay({
  lastActivityTimestamp,
  reasons,
  workCenterProductionLineId,
  operatorUserId,
  onDismiss,
}: DowntimeOverlayProps) {
  const [elapsedSeconds, setElapsedSeconds] = useState(0);
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState('');

  useEffect(() => {
    const tick = () => {
      setElapsedSeconds(Math.floor((Date.now() - lastActivityTimestamp) / 1000));
    };
    tick();
    const id = setInterval(tick, 1000);
    return () => clearInterval(id);
  }, [lastActivityTimestamp]);

  const grouped = useMemo(() => {
    const map = new Map<string, { categoryName: string; reasons: DowntimeReason[] }>();
    for (const r of reasons) {
      const key = r.downtimeReasonCategoryId;
      if (!map.has(key)) {
        map.set(key, { categoryName: r.categoryName, reasons: [] });
      }
      map.get(key)!.reasons.push(r);
    }
    return Array.from(map.values());
  }, [reasons]);

  const handleSelectReason = async (reasonId: string) => {
    if (submitting) return;
    setSubmitting(true);
    setError('');
    try {
      const now = new Date().toISOString();
      const startedAt = new Date(lastActivityTimestamp).toISOString();
      await downtimeEventApi.create({
        workCenterProductionLineId,
        operatorUserId,
        startedAt,
        endedAt: now,
        downtimeReasonId: reasonId,
        isAutoGenerated: false,
      });
      onDismiss();
    } catch {
      setError('Failed to record downtime. Tap a reason to try again.');
      setSubmitting(false);
    }
  };

  const stopPropagation = (e: React.SyntheticEvent) => e.stopPropagation();

  return (
    <div
      className={styles.overlay}
      data-testid="downtime-overlay"
      onPointerDown={stopPropagation}
      onTouchStart={stopPropagation}
    >
      <div className={styles.header}>
        <span className={styles.title}>Looks like there was some downtime</span>
        <span className={styles.subtitle}>Select a reason to continue</span>
      </div>

      <div className={styles.timer} data-testid="downtime-timer">
        {formatElapsed(elapsedSeconds)}
      </div>

      {error && (
        <div className={styles.errorBanner} role="alert" data-testid="downtime-error">
          {error}
        </div>
      )}

      {grouped.map(group => (
        <div key={group.categoryName} className={styles.categoryGroup}>
          <div className={styles.categoryTitle}>{group.categoryName}</div>
          <div className={styles.reasonGrid}>
            {group.reasons.map(reason => (
              <button
                key={reason.id}
                className={`${styles.reasonButton} ${submitting ? styles.reasonButtonDisabled : ''}`}
                onClick={() => handleSelectReason(reason.id)}
                disabled={submitting}
                data-testid={`reason-${reason.id}`}
              >
                {reason.name}
              </button>
            ))}
          </div>
        </div>
      ))}
    </div>
  );
}
